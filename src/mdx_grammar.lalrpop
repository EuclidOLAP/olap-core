use crate::mdx_tokens::{Token, LexicalError};

use crate::mdx_ast;
use crate::mdx_ast::AstSeg;
use crate::mdx_ast::AstFormulaObject;
use crate::mdx_ast::AstFormulaObject::{CustomFormulaMember};
use crate::mdx_ast::{AstFactory, AstTerm, AstExpression};
use crate::mdx_ast::AstFactory::{FactoryNum, FactoryStr, FactorySegs,FactoryTuple,FactoryExp};
use crate::mdx_ast::{AstLevelFunction, AstLevelFnLevel, AstLevelFnLevels};
use crate::mdx_ast::{AstMemberFunction, AstMemberFnParent, AstMemberFnClosingPeriod, AstMemberFnOpeningPeriod};
use crate::mdx_ast::{AstMemberFnCurrentMember};
use crate::mdx_ast::{AstSetFunction, AstSetFnChildren};
use crate::mdx_ast::{AstExpFunction, AstExpFnAvg, AstExpFnCount};
use crate::mdx_ast::{AstExpFnName};
use crate::mdx_ast::{AstExpFnLookupCube};
use crate::mdx_ast::AstExpFnIIf;
use crate::mdx_ast::AstBoolExp;
use crate::mdx_ast::AstBoolTerm;
use crate::mdx_ast::AstBoolFactory;
use crate::mdx_ast::AstBoolFunction;
use crate::mdx_ast::AstBoolFnIsLeaf;

use crate::exmdx::exp_func::{AstExpFuncSum, AstExpFuncMax, AstExpFuncMin};
use crate::exmdx::set_func::*;

grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "with" => Token::With,
    "member" => Token::Member,
    "set" => Token::Set,
    "as" => Token::As,

    "select" => Token::Select,
    "on" => Token::On,
    "from" => Token::From,
    "where" => Token::Where,
    "BracketedString" => Token::BracketedString(<String>),
    "QuotedString" => Token::QuotedString(<String>),

    "Columns" => Token::Columns,
    "Rows" => Token::Rows,
    "Pages" => Token::Pages,
    "Chapters" => Token::Chapters,
    "Sections" => Token::Sections,

    "+" => Token::Plus,
    "-" => Token::Minus,
    "*" => Token::Multiplied,
    "/" => Token::Divided,

    "," => Token::Comma,
    "&" => Token::Ampersand,
    "." => Token::Dot,
    "int" => Token::Integer(<u64>),
    "double" => Token::Double(<f64>),

    "(" => Token::RoundBracketLeft,
    ")" => Token::RoundBracketRight,
    "{" => Token::CurlyBraceLeft,
    "}" => Token::CurlyBraceRight,

    "<" => Token::LT,
    "<=" => Token::LE,
    "=" => Token::EQ,
    "<>" => Token::NE,
    ">" => Token::GT,
    ">=" => Token::GE,

    ";" => Token::Semicolon,

    "Parent" => Token::Parent,
    "CurrentMember" => Token::CurrentMember,
    "ClosingPeriod" => Token::ClosingPeriod,
    "OpeningPeriod" => Token::OpeningPeriod,

    "Children" => Token::Children,
    "BottomPercent" => Token::BottomPercent,
    "Crossjoin" => Token::Crossjoin,
    "Descendants" => Token::Descendants,
    "Except" => Token::Except,

    "Avg" => Token::Avg,
    "Sum" => Token::Sum,
    "Max" => Token::Max,
    "Min" => Token::Min,
    "Count" => Token::Count,
    "Tunnel" => Token::Tunnel,
    "IIf" => Token::IIf,

    "Name" => Token::Name,

    "Level" => Token::Level,
    "Levels" => Token::Levels,

    "Not" => Token::Not,
    "Or" => Token::Or,
    "And" => Token::And,

    "IsLeaf" => Token::IsLeaf,
  }
}

pub SelectionMDX: mdx_ast::AstSelectionStatement = {
  "select" <axes:Axes> "from" <cube:Segments> (";")? => {
    mdx_ast::AstSelectionStatement {
      formula_objs: vec![],
      axes,
      cube,
      basic_slice: None,
    }
  },
  "select" <axes:Axes> "from" <cube:Segments> "where" <tuple:TupleWrap> (";")? => {
    mdx_ast::AstSelectionStatement {
      formula_objs: vec![],
      axes,
      cube,
      basic_slice: Some(tuple),
    }
  },
  "with" <cfos:CustomFormulaObjects> "select" <axes:Axes> "from" <cube:Segments> (";")? => {
    mdx_ast::AstSelectionStatement {
      formula_objs: cfos,
      axes,
      cube,
      basic_slice: None,
    }
  },
  "with" <cfos:CustomFormulaObjects> "select" <axes:Axes> "from" <cube:Segments> "where" <tuple:TupleWrap> (";")? => {
    mdx_ast::AstSelectionStatement {
      formula_objs: cfos,
      axes,
      cube,
      basic_slice: Some(tuple),
    }
  },
}

CustomFormulaObjects: Vec<AstFormulaObject> = {
  <fm:FormulaMember> => {
    vec![fm]
  },
  <fs:FormulaSet> => {
    vec![fs]
  },
  <cfos:CustomFormulaObjects> (",")? <fm:FormulaMember> => {
    let mut list = cfos;
    list.push(fm);
    list
  },
  <cfos:CustomFormulaObjects> (",")? <fs:FormulaSet> => {
    let mut list = cfos;
    list.push(fs);
    list
  }
}

FormulaMember: AstFormulaObject = {
  "member" <sw:SegmentsWrap> "as" <exp:Expression> => {
    CustomFormulaMember(sw, exp)
  }
}

FormulaSet: AstFormulaObject = {
  "set" <_sw:SegmentsWrap> "as" => {
    // CustomFormulaSet
    todo!("<<< MDX Grammar Exception >>> CustomFormulaSet not implemented yet.")
  }
}

// multi-dimensional object segment
Seg: AstSeg = {
  "&" <int:"int"> => {
    AstSeg::Gid(int)
  },
  "&" <int:"int"> <bra_str:"BracketedString"> => {
    AstSeg::GidStr(int, bra_str)
  },
  <bra_str:"BracketedString"> => {
    AstSeg::Str(bra_str)
  },
  <mfn: MemberFunction> => {
    AstSeg::MemberFunction(mfn)
  },
  <setfn: SetFnSpec> => {
    AstSeg::SetFunction(setfn)
  },
  <exp_fn: ExpFnSpec> => {
    AstSeg::ExpFn(exp_fn)
  },
  <lv_fn: LevelFunction> => {
    AstSeg::LevelFn(lv_fn)
  },
}

Segments: Vec<AstSeg> = {
  <seg:Seg> => {
    let mut list = Vec::with_capacity(6);
    list.push(seg);
    list
  },
  <segs:Segments> "." <seg:Seg> => {
    let mut list = segs;
    list.push(seg);
    list
  }
}

SegmentsWrap: mdx_ast::AstSegments = {
  <segs:Segments> => {
    mdx_ast::AstSegments{segs}
  }
}

// Segs_Obj: AstSegsObj = {
//   <seg: Seg> => {},
//   <segs: Segs_Obj> "." <seg: Seg> => {},
// }

MemberFunction: AstMemberFunction = {
  <parent: MemberFnParent> => {
    AstMemberFunction::Parent(parent)
  },
  <cp: MemberFnClosingPeriod> => {
    AstMemberFunction::ClosingPeriod(cp)
  },
  <op: MemberFnOpeningPeriod> => {
    AstMemberFunction::OpeningPeriod(op)
  },
  <cur_mbr: MemberFnCurrentMember> => {
    AstMemberFunction::CurrentMember(cur_mbr)
  },
}

MemberFnParent: AstMemberFnParent = {
  "Parent" => {
    AstMemberFnParent::NoParam
  },
  "Parent" "(" ")" => {
    AstMemberFnParent::NoParam
  },
  "Parent" "(" <segments: SegmentsWrap> ")" => {
    AstMemberFnParent::HasParam(segments)
  },
}

MemberFnClosingPeriod: AstMemberFnClosingPeriod = {
  "ClosingPeriod" => {
    AstMemberFnClosingPeriod::NoParam
  },
  "ClosingPeriod" "(" ")" => {
    AstMemberFnClosingPeriod::NoParam
  },
  "ClosingPeriod" "(" <level_segs: SegmentsWrap> ")" => {
    AstMemberFnClosingPeriod::OneParam(level_segs)
  },
  "ClosingPeriod" "(" <level_segs: SegmentsWrap> "," <member_segs: SegmentsWrap> ")" => {
    AstMemberFnClosingPeriod::TwoParams(level_segs, member_segs)
  },
}

MemberFnOpeningPeriod: AstMemberFnOpeningPeriod = {
  "OpeningPeriod" => {
    AstMemberFnOpeningPeriod::NoParam
  },
  "OpeningPeriod" "(" ")" => {
    AstMemberFnOpeningPeriod::NoParam
  },
  "OpeningPeriod" "(" <level_segs: SegmentsWrap> ")" => {
    AstMemberFnOpeningPeriod::OneParam(level_segs)
  },
  "OpeningPeriod" "(" <level_segs: SegmentsWrap> "," <member_segs: SegmentsWrap> ")" => {
    AstMemberFnOpeningPeriod::TwoParams(level_segs, member_segs)
  },
}

MemberFnCurrentMember: AstMemberFnCurrentMember = {
  "CurrentMember" => {
    AstMemberFnCurrentMember::NoParam
  },
  "CurrentMember" "(" ")" => {
    AstMemberFnCurrentMember::NoParam
  },
  "CurrentMember" "(" <segments: SegmentsWrap> ")" => {
    AstMemberFnCurrentMember::InnerParam(segments)
  },
}

LevelFunction: AstLevelFunction = {
  <lv: LvFnLevel> => {
    AstLevelFunction::Level(lv)
  },
  <lvs: LvFnLevels> => {
    AstLevelFunction::Levels(lvs)
  },
}

LvFnLevel: AstLevelFnLevel = {
  "Level" => {
    AstLevelFnLevel::NoParam
  },
  "Level" "(" ")" => {
    AstLevelFnLevel::NoParam
  },
  "Level" "(" <segments: SegmentsWrap> ")" => {
    AstLevelFnLevel::OneParam(segments)
  },
}

LvFnLevels: AstLevelFnLevels = {
  "Levels" "(" <idx_exp: Expression> ")" => {
    AstLevelFnLevels::new(None, idx_exp)
  },
  "Levels" "(" <dim_segs: SegmentsWrap> "," <idx_exp: Expression> ")" => {
    AstLevelFnLevels::new(Some(dim_segs), idx_exp)
  },
}

Expression: AstExpression = {
  <term:Term> => {
    AstExpression {
      terms: vec![(' ', term)],
    }
  },
  <exp:Expression> "+" <term:Term> => {
    let mut e = exp;
    e.terms.push(('+', term));
    e
  },
  <exp:Expression> "-" <term:Term> => {
    let mut e = exp;
    e.terms.push(('-', term));
    e
  }
}

Term: AstTerm = {
  <factory:Factory> => {
    AstTerm {
      factories: vec![(' ', factory)],
    }
  },
  <term:Term> "*" <factory:Factory> => {
    let mut t = term;
    t.factories.push(('*', factory));
    t
  },
  <term:Term> "/" <factory:Factory> => {
    let mut t = term;
    t.factories.push(('/', factory));
    t
  }
}

Factory: AstFactory = {
  <value:"double"> => {
    FactoryNum(value)
  },
  <int_val:"int"> => {
    let double_val: f64 = int_val as f64;
    FactoryNum(double_val)
  },
  <str:"QuotedString"> => {
    FactoryStr(str)
  },
  <segs_wrap:SegmentsWrap> => {
    FactorySegs(segs_wrap)
  },
  <tuple_wrap:TupleWrap_2> => {
    FactoryTuple(tuple_wrap)
  },
  "(" <exp:Expression> ")" => {
    FactoryExp(exp)
  },
}

Tuple: Vec<mdx_ast::AstSegments> = {
  <sw:SegmentsWrap> => {
    vec![sw]
  },
  <tuple:Tuple> "," <sw:SegmentsWrap> => {
    let mut list = tuple;
    list.push(sw);
    list
  }
}

TupleWrap: mdx_ast::AstTuple = {
  "(" <tuple:Tuple> ")" => {
    mdx_ast::AstTuple::SegsList(tuple)
  }
}

SetFnSpec: AstSetFunction = {
  <chir: SetFnChildrenSpec> => {
    AstSetFunction::Children(chir)
  },
  // <set_fn: Set_Func_ XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX> => { AstSetFunction::XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX(set_fn) },

  <set_fn: Set_Func_BottomPercent> => { AstSetFunction::BottomPercent(set_fn) },
  <set_fn: Set_Func_CrossJoin> => { AstSetFunction::CrossJoin(set_fn) },
  <set_fn: Set_Func_Descendants> => { AstSetFunction::Descendants(set_fn) },
  <set_fn: Set_Func_Except> => { AstSetFunction::Except(set_fn) },

  // AddCalculatedMembers        ____	SSAS	____	____
  // AllMembers                  ____	SSAS	____	____
  // Ancestors                   ....	SSAS	____	intc
  // Ascendants                  ____	SSAS	____	____
  // Axis                        ____	SSAS	____	____
  // BottomCount                 ....	SSAS	Esbs	intc
  // BottomSum                   ....	SSAS	Esbs	intc
  // CurrentOrdinal              ____	SSAS	____	____
  // Distinct                    ....	SSAS	Esbs	intc
  // DrilldownLevel              ....	SSAS	____	intc
  // DrilldownLevelBottom        ....	SSAS	____	intc
  // DrillDownLevelTop           ....	SSAS	____	intc
  // DrillDownMember             ....	SSAS	____	intc
  // DrillDownMemberBottom       ....	SSAS	____	intc
  // DrillDownMemberTop          ....	SSAS	____	intc
  // DrillupLevel                ....	SSAS	____	intc
  // DrillupMember               ....	SSAS	____	intc
  // Exists                      ____	SSAS	____	____
  // Extract                     ....	SSAS	Esbs	intc
  // Filter                      ....	SSAS	____	intc
  // Generate                    ....	SSAS	Esbs	____
  // Head                        ....	SSAS	Esbs	____
  // Hierarchize                 ____	SSAS	____	____
  // Intersect                   ....	SSAS	Esbs	intc
  // LastPeriods                 ____	SSAS	____	____
  // LateralMembers              ....	____	____	____
  // Members                     ....	____	____	intc
  // Members (Set)               ____	SSAS	____	____
  // Mtd                         ____	SSAS	____	intc
  // NameToSet                   ____	SSAS	____	____
  // NonEmptyCrossjoin           ____	SSAS	____	____
  // Order                       ....	SSAS	____	intc
  // PeriodsToDate               ....	SSAS	Esbs	intc
  // Qtd                         ....	SSAS	____	intc
  // Siblings                    ____	SSAS	____	____
  // StripCalculatedMembers      ____	SSAS	____	____
  // StrToSet                    ____	SSAS	____	____
  // Subset                      ....	SSAS	Esbs	____
  // Tail                        ....	SSAS	Esbs	____
  // ToggleDrillState            ____	SSAS	____	____
  // TopCount                    ....	SSAS	____	intc
  // TopPercent                  ....	SSAS	____	intc
  // TopSum                      ....	SSAS	Esbs	intc
  // TupleRange                  ____	____	Esbs	____
  // Union                       ....	SSAS	Esbs	intc
  // Unorder                     ____	SSAS	____	____
  // VisualTotals                ____	SSAS	____	____
  // Wtd                         ____	SSAS	____	intc
  // Ytd                         ....	SSAS	____	intc
}

SetFnChildrenSpec: AstSetFnChildren = {
  "Children" => {
    AstSetFnChildren::NoParam
  },
  "Children" "(" ")" => {
    AstSetFnChildren::NoParam
  },
  "Children" "(" <segments: SegmentsWrap> ")" => {
    AstSetFnChildren::InnerParam(segments)
  },
}

Set_Func_BottomPercent: AstSetFnBottomPercent = {
  // SSAS:     BottomPercent(Set_Expression, Percentage, Numeric_Expression)
  // Essbase:  BottomPercent ( set, percentage, numeric_value_expression )
  // "BottomPercent" "(" <percentage: Expression> "," <numeric: Expression> ")" => {
  //   todo!()
  // },

  "BottomPercent" "(" <segs_set: SegmentsWrap> "," <percentage: Expression> "," <numeric: Expression> ")" => {
    todo!()
  },
  "BottomPercent" "(" <brace_set: SetWrap> "," <percentage: Expression> "," <numeric: Expression> ")" => {
    todo!()
  },
}

Set_Func_CrossJoin: AstSetFnCrossJoin = {
  // Standard syntax  
  // Crossjoin(Set_Expression1 ,Set_Expression2 [,...n] )  

  // Alternate syntax  
  // Set_Expression1 * Set_Expression2 [* ...n] 
  "Crossjoin" "(" <set_fn: CrossJoin_Sets> ")" => {
    set_fn
  },
}

CrossJoin_Sets: AstSetFnCrossJoin = {
  <brace_set: SetWrap> => {
    todo!()
  },
  <segs_set: SegmentsWrap> => {
    todo!()
  },
  <set_fn: CrossJoin_Sets> "," <brace_set: SetWrap> => {
        todo!()
  },
  <set_fn: CrossJoin_Sets> "," <segs_set: SegmentsWrap> => {
    todo!()
  },
}

Set_Func_Descendants: AstSetFnDescendants = {
  // SSAS:     
  // Member expression syntax using a level expression  
  // Descendants(Member_Expression [ , Level_Expression [ ,Desc_Flag ] ] )  

  // Member expression syntax using a numeric expression  
  // Descendants(Member_Expression [ , Distance [ ,Desc_Flag ] ] )  

  // Set expression syntax using a level expression  
  // Descendants(Set_Expression [ , Level_Expression [ ,Desc_Flag ] ] )  

  // Member expression syntax using a numeric expression  
  // Descendants(Set_Expression [ , Distance [ ,Desc_Flag ] ] )

  // Essbase:  
  // Descendants ( member , [{ layer | index }[, Desc_flags ]])

  // "Descendants" "(" ")" => {
  //   todo!()
  // },

  // "Descendants" "(" <segs_lv: SegmentsWrap> ")" => {
  //   todo!()
  // },
  // "Descendants" "(" <distance: Expression> ")" => {
  //   todo!()
  // },

  // "Descendants" "(" <segs_lv: SegmentsWrap> "," <str: "QuotedString"> ")" => {
  //   todo!()
  // },
  // "Descendants" "(" <distance: Expression> "," <str: "QuotedString"> ")" => {
  //   todo!()
  // },


  "Descendants" "(" <segs_mem: SegmentsWrap> ")" => {
    todo!()
  },

  "Descendants" "(" <segs_mem: SegmentsWrap> "," <segs_lv: SegmentsWrap> ")" => {
    todo!()
  },
  // "Descendants" "(" <segs_mem: SegmentsWrap> "," <distance: Expression> ")" => {
  //   todo!()
  // },

  "Descendants" "(" <segs_mem: SegmentsWrap> "," <segs_lv: SegmentsWrap> "," <str: "QuotedString"> ")" => {
    todo!()
  },
  // "Descendants" "(" <segs_mem: SegmentsWrap> "," <distance: Expression> "," <str: "QuotedString"> ")" => {
  //   todo!()
  // },
}

Set_Func_Except: AstSetFnExcept = {
  // SSAS:     XXXXXXXXXXXXXXXXXXXXXXXXXXXX
  // Except(Set_Expression1, Set_Expression2 [, ALL ] )

  // Essbase:  XXXXXXXXXXXXXXXXXXXXXXXXXXXX
  // Except ( set1, set2 [,ALL] )

  "Except" "(" <brace_set_2: SetWrap> ")" => {
    todo!()
  },
  "Except" "(" <segs_set_2: SegmentsWrap> ")" => {
    todo!()
  },

  "Except" "(" <brace_set_2: SetWrap> "," <str: "QuotedString"> ")" => {
    todo!()
  },
  "Except" "(" <segs_set_2: SegmentsWrap> "," <str: "QuotedString"> ")" => {
    todo!()
  },


  "Except" "(" <brace_set_1: SetWrap> "," <brace_set_2: SetWrap> ")" => {
    todo!()
  },
  "Except" "(" <brace_set_1: SetWrap> "," <segs_set_2: SegmentsWrap> ")" => {
    todo!()
  },
  "Except" "(" <segs_set_1: SegmentsWrap> "," <brace_set_2: SetWrap> ")" => {
    todo!()
  },
  "Except" "(" <segs_set_1: SegmentsWrap> "," <segs_set_2: SegmentsWrap> ")" => {
    todo!()
  },

  "Except" "(" <brace_set_1: SetWrap> "," <brace_set_2: SetWrap> "," <str: "QuotedString"> ")" => {
    todo!()
  },
  "Except" "(" <brace_set_1: SetWrap> "," <segs_set_2: SegmentsWrap> "," <str: "QuotedString"> ")" => {
    todo!()
  },
  "Except" "(" <segs_set_1: SegmentsWrap> "," <brace_set_2: SetWrap> "," <str: "QuotedString"> ")" => {
    todo!()
  },
  "Except" "(" <segs_set_1: SegmentsWrap> "," <segs_set_2: SegmentsWrap> "," <str: "QuotedString"> ")" => {
    todo!()
  },
}

ExpFnSpec: AstExpFunction = {
  <avg: ExpFnAvgSpec> => {
    AstExpFunction::Avg(avg)
  },
  <count: ExpFnCountSpec> => {
    AstExpFunction::Count(count)
  },
  <iif: ExpFnIIfSpec> => {
    AstExpFunction::IIf(iif)
  },
  <lookup_cube: ExpFnLookupCubeSpec> => {
    AstExpFunction::LookupCube(lookup_cube)
  },
  <name: ExpFnNameSpec> => {
    AstExpFunction::Name(name)
  },
  <exp_fn: Exp_Func_Sum> => {
    AstExpFunction::Sum(exp_fn)
  },
  <exp_fn: Exp_Func_Max> => {
    AstExpFunction::Max(exp_fn)
  },
  <exp_fn: Exp_Func_Min> => {
    AstExpFunction::Min(exp_fn)
  },
}

ExpFnNameSpec: AstExpFnName = {
  "Name" => {
    AstExpFnName::NoParam
  },
  "Name" "(" ")" => {
    AstExpFnName::NoParam
  },
  "Name" "(" <olap_obj_segs: SegmentsWrap> ")" => {
    AstExpFnName::InnerParam(olap_obj_segs)
  },
}

ExpFnCountSpec: AstExpFnCount = {
  "Count" => {
    AstExpFnCount::NoParam
  },
  "Count" "(" ")" => {
    AstExpFnCount::NoParam
  },
  "Count" "(" <set: SetWrap> ")" => {
    AstExpFnCount::InnerParam(set)
  },
}

ExpFnAvgSpec: AstExpFnAvg = {
  "Avg" => {
    AstExpFnAvg::NoParam
  },
  "Avg" "(" ")" => {
    AstExpFnAvg::NoParam
  },
  "Avg" "(" <set: SetWrap> ")" => {
    AstExpFnAvg::InnerParam(set)
  },
}

Exp_Func_Sum: AstExpFuncSum = {
  "Sum" ("(" ")")? => {
    AstExpFuncSum::Simple
  },
  // "Sum" "(" <exp: Expression> ")" => {},
  "Sum" "(" <segs_set: SegmentsWrap> ")" => {
    AstExpFuncSum::SegsSet(segs_set)
  },
  "Sum" "(" <segs_set: SegmentsWrap> "," <exp: Expression> ")" => {
    AstExpFuncSum::SegsSetExp(segs_set, exp)
  },
  "Sum" "(" <cb_set: SetWrap> ")" => {
    AstExpFuncSum::BraceSet(cb_set)
  },
  "Sum" "(" <cb_set: SetWrap> "," <exp: Expression> ")" => {
    AstExpFuncSum::BraceSetExp(cb_set, exp)
  },
}

Exp_Func_Max: AstExpFuncMax = {
  "Max" ("(" ")")? => {
    AstExpFuncMax::Simple
  },
  // "Max" "(" <exp: Expression> ")" => {},
  "Max" "(" <segs_set: SegmentsWrap> ")" => {
    AstExpFuncMax::SegsSet(segs_set)
  },
  "Max" "(" <segs_set: SegmentsWrap> "," <exp: Expression> ")" => {
    AstExpFuncMax::SegsSetExp(segs_set, exp)
  },
  "Max" "(" <cb_set: SetWrap> ")" => {
    AstExpFuncMax::BraceSet(cb_set)
  },
  "Max" "(" <cb_set: SetWrap> "," <exp: Expression> ")" => {
    AstExpFuncMax::BraceSetExp(cb_set, exp)
  },
}

Exp_Func_Min: AstExpFuncMin = {
  "Min" ("(" ")")? => {
    AstExpFuncMin::Simple
  },
  // "Min" "(" <exp: Expression> ")" => {},
  "Min" "(" <segs_set: SegmentsWrap> ")" => {
    AstExpFuncMin::SegsSet(segs_set)
  },
  "Min" "(" <segs_set: SegmentsWrap> "," <exp: Expression> ")" => {
    AstExpFuncMin::SegsSetExp(segs_set, exp)
  },
  "Min" "(" <cb_set: SetWrap> ")" => {
    AstExpFuncMin::BraceSet(cb_set)
  },
  "Min" "(" <cb_set: SetWrap> "," <exp: Expression> ")" => {
    AstExpFuncMin::BraceSetExp(cb_set, exp)
  },
}

ExpFnIIfSpec: AstExpFnIIf = {
  "IIf" "(" <bool_exp: BoolExpression> "," <exp_t: Expression> "," <exp_f: Expression> ")" => {
    AstExpFnIIf {
      bool_exp,
      exp_t,
      exp_f,
    }
  }
}

ExpFnLookupCubeSpec: AstExpFnLookupCube = {
    "Tunnel" "(" <cube_segs: SegmentsWrap> "," <exp_on_another_cube: Expression> ")" => {
      AstExpFnLookupCube::new(Some(cube_segs), exp_on_another_cube)
    },
    "Tunnel" "(" <exp_on_another_cube: Expression> ")" => {
      AstExpFnLookupCube::new(None, exp_on_another_cube)
    },
}

Set: Vec<mdx_ast::AstTuple> = {
  <ast_tp:TupleWrap> => {
    vec![ast_tp]
  },
  <set:Set> "," <ast_tp:TupleWrap> => {
    let mut list = set;
    list.push(ast_tp);
    list
  }
}

SetWrap: mdx_ast::AstSet = {
  "{" <tuples:Set> "}" => {
    mdx_ast::AstSet::Tuples(tuples)
  }
}

// Tuples: Vec<AstTuple> = {
//   <tuple: Tuple> => {},
//   <tuples: Tuples> "," <tuple: Tuple> => {},
// }

// Curly_Brace_Set: AstCurlyBraceSet = {
//   "{" <tuple_list: Tuples> "}" => {

//   },
// }

BoolExpression: AstBoolExp = {
  <bt: BoolTerm> => {
    AstBoolExp::BoolTerm(bt)
  },
  "Not" <bt: BoolTerm> => {
    AstBoolExp::NotBoolTerm(bt)
  },
  <bool_exp: BoolExpression> "Or" <bt: BoolTerm> => {
    AstBoolExp::BoolExpOrBoolTerm(Box::new(bool_exp), bt)
  }
}

BoolTerm: AstBoolTerm = {
  <bf: BoolFactory> => {
    AstBoolTerm::BoolFactory(bf)
  },
  <bt: BoolTerm> "And" <bf: BoolFactory> => {
    AstBoolTerm::BoolTermAndBoolFactory(Box::new(bt), bf)
  }
}

BoolFactory: AstBoolFactory = {
  <exp_left: Expression> "<" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from("<"), exp_right)
  },
  <exp_left: Expression> "<=" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from("<="), exp_right)
  },
  <exp_left: Expression> "=" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from("="), exp_right)
  },
  <exp_left: Expression> "<>" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from("<>"), exp_right)
  },
  <exp_left: Expression> ">" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from(">"), exp_right)
  },
  <exp_left: Expression> ">=" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from(">="), exp_right)
  },
  "(" <bool_exp: BoolExpression> ")" => {
    AstBoolFactory::BoolExp(Box::new(bool_exp))
  },
  <bool_fn: BoolFunction> => {
    AstBoolFactory::BoolFn(bool_fn)
  }
}

BoolFunction: AstBoolFunction = {
  <is_leaf: BoolFnIsLeaf> => {
    AstBoolFunction::IsLeaf(is_leaf)
  }
}

BoolFnIsLeaf: AstBoolFnIsLeaf = {
  // "IsLeaf" => {
  //   AstBoolFnIsLeaf::new(None)
  // },
  // "IsLeaf" "(" ")" => {
  //   AstBoolFnIsLeaf::new(None)
  // },
  "IsLeaf" "(" <member_segs: SegmentsWrap> ")" => {
    AstBoolFnIsLeaf::new(member_segs)
  },
}

TupleWrap_2: mdx_ast::AstTuple = {
  "(" <sw:SegmentsWrap> "," <tuple:Tuple> ")" => {
    let mut list = tuple; // Vec<mdx_ast::AstSegments>
    list.insert(0, sw); // mdx_ast::AstSegments
    mdx_ast::AstTuple::SegsList(list)
  }
}

// COLUMNS | ROWS | PAGES | CHAPTERS | SECTIONS | AXIS (<unsigned_integer>)
Axis: mdx_ast::AstAxis = {
  <ast_set:SetWrap> "on" <axpos:AxisPos> => {
    mdx_ast::AstAxis::SetDefinition {
      ast_set,
      pos: axpos,
    }
  }
}

AxisPos: u64 = {
  <axpos:"int"> => axpos,
  "Columns"     => 0,
  "Rows"        => 1,
  "Pages"       => 2,
  "Chapters"    => 3,
  "Sections"    => 4,
}

Axes: Vec<mdx_ast::AstAxis> = {
  <axis:Axis> => {
    vec![axis]
  },
  <axes:Axes> "," <axis:Axis> => {
    let mut list = axes;
    list.push(axis);
    list
  }
}
