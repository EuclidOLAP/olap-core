use crate::mdx_tokens::{Token, LexicalError};

use crate::mdx_ast::AstSeg;
use crate::mdx_ast::{AstFactory, AstTerm, AstExpression};
use crate::mdx_ast::AstFactory::{FactoryNum, FactoryStr, FactorySegs,FactoryTuple,FactoryExp};
use crate::mdx_ast::{AstLevelFunction, AstLevelFnLevel, AstLevelFnLevels};
use crate::mdx_ast::{AstMemberFunction, AstMemberFnParent, AstMemberFnClosingPeriod, AstMemberFnOpeningPeriod};
use crate::mdx_ast::{AstMemberFnCurrentMember};
use crate::mdx_ast::{AstSetFunction, AstSetFnChildren};
use crate::mdx_ast::{AstExpFunction, AstExpFnAvg, AstExpFnCount};
use crate::mdx_ast::{AstExpFnName};
use crate::mdx_ast::{AstExpFnLookupCube};
use crate::mdx_ast::AstExpFnIIf;
use crate::mdx_ast::AstBoolExp;
use crate::mdx_ast::AstBoolTerm;
use crate::mdx_ast::AstBoolFactory;
use crate::mdx_ast::AstBoolFunction;
use crate::mdx_ast::AstBoolFnIsLeaf;

use crate::exmdx::ast::AstSegsObj;
use crate::exmdx::ast::{AstMdxStatement, AstSet, AstTuple, AstAxis, AstCustomObject};

use crate::exmdx::exp_func::{AstExpFuncSum, AstExpFuncMax, AstExpFuncMin};

grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "with" => Token::With,
    "member" => Token::Member,
    "set" => Token::Set,
    "as" => Token::As,

    "select" => Token::Select,
    "on" => Token::On,
    "from" => Token::From,
    "where" => Token::Where,
    "BracketedString" => Token::BracketedString(<String>),
    "QuotedString" => Token::QuotedString(<String>),

    "Columns" => Token::Columns,
    "Rows" => Token::Rows,
    "Pages" => Token::Pages,
    "Chapters" => Token::Chapters,
    "Sections" => Token::Sections,

    "+" => Token::Plus,
    "-" => Token::Minus,
    "*" => Token::Multiplied,
    "/" => Token::Divided,

    "," => Token::Comma,
    "&" => Token::Ampersand,
    "." => Token::Dot,
    "unsigned_int" => Token::Integer(<u64>),
    "double" => Token::Double(<f64>),

    "(" => Token::RoundBracketLeft,
    ")" => Token::RoundBracketRight,
    "{" => Token::CurlyBraceLeft,
    "}" => Token::CurlyBraceRight,

    "<" => Token::LT,
    "<=" => Token::LE,
    "=" => Token::EQ,
    "<>" => Token::NE,
    ">" => Token::GT,
    ">=" => Token::GE,

    ";" => Token::Semicolon,

    "Parent" => Token::Parent,
    "CurrentMember" => Token::CurrentMember,
    "ClosingPeriod" => Token::ClosingPeriod,
    "OpeningPeriod" => Token::OpeningPeriod,

    "Children" => Token::Children,

    "Avg" => Token::Avg,
    "Sum" => Token::Sum,
    "Max" => Token::Max,
    "Min" => Token::Min,
    "Count" => Token::Count,
    "Tunnel" => Token::Tunnel,
    "IIf" => Token::IIf,

    "Name" => Token::Name,

    "Level" => Token::Level,
    "Levels" => Token::Levels,

    "Not" => Token::Not,
    "Or" => Token::Or,
    "And" => Token::And,

    "IsLeaf" => Token::IsLeaf,
  }
}

// code review mark <<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// code review mark <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

// MDX Function Reference
// https://docs.oracle.com/en/database/other-databases/essbase/21/esscq/mdx-function-list.html
// https://learn.microsoft.com/en-us/sql/mdx/mdx-function-reference-mdx?view=sql-server-ver17
// https://www.ibm.com/docs/en/planning-analytics/2.0.0?topic=references-mdx-function-support

pub MdxStatement: AstMdxStatement = {
  <querying: Slicing_Querying> (";")? => {
    AstMdxStatement::new(vec![], querying)
  },
  "with" <custom_objs: With_Custom_Objects> <querying: Slicing_Querying> (";")? => {
    AstMdxStatement::new(custom_objs, querying)
  },
}

Slicing_Querying: (Vec<AstAxis>, AstSegsObj, Option<AstTuple>) = {
  "select" <axes: Axes> "from" <cube_segs: Segs_Obj> => {
    (axes, cube_segs, None)
  },
  "select" <axes: Axes> "from" <cube_segs: Segs_Obj> "where" <ast_tup: Bracket_Tuple> => {
    (axes, cube_segs, Some(ast_tup))
  },
  "select" <axes: Axes> "from" <cube_segs: Segs_Obj> "where" <segs_obj: Segs_Obj> => {
    (axes, cube_segs, Some(AstTuple::SegsObj(segs_obj)))
  },
}

With_Custom_Objects: Vec<AstCustomObject> = {
  <cus_obj: Custom_Object> => {
    vec![cus_obj]
  },
  <cus_objs: With_Custom_Objects> (",")? <cus_obj: Custom_Object> => {
    let mut list = cus_objs;
    list.push(cus_obj);
    list
  },
}

Custom_Object: AstCustomObject = {
  "member" <for_meb_segs: Segs_Obj> "as" <exp: Expression> => {
    AstCustomObject::FormulaMember(for_meb_segs, exp)
  },
  "set" <cus_set_segs: Segs_Obj> "as" <ast_set: Brace_Set> => {
    AstCustomObject::CustomSet(cus_set_segs, ast_set)
  },
  "set" <cus_set_segs: Segs_Obj> "as" <segs_obj: Segs_Obj> => {
    AstCustomObject::CustomSet(cus_set_segs, AstSet::SegsObj(segs_obj))
  },
}

Bracket_Tuple: AstTuple = {
  "(" <segs_objs: Segs_Objects> ")" => {
    AstTuple::SegsObjects(segs_objs)
  },
}

Brace_Set: AstSet = {
  "{" <tuples: Tuples> "}" => {
    AstSet::Tuples(tuples)
  },
}

Tuples: Vec<AstTuple> = {
  <tuple_segs: Segs_Obj> => {
    vec![AstTuple::SegsObj(tuple_segs)]
  },
  <bracket_tup: Bracket_Tuple> => {
    vec![bracket_tup]
  },
  <tuples: Tuples> "," <tuple_segs: Segs_Obj> => {
    let mut list = tuples;
    list.push(AstTuple::SegsObj(tuple_segs));
    list
  },
  <tuples: Tuples> "," <bracket_tup: Bracket_Tuple> => {
    let mut list = tuples;
    list.push(bracket_tup);
    list
  },
}

Segs_Objects: Vec<AstSegsObj> = {
  <segs_obj: Segs_Obj> => {
    vec![segs_obj]
  },
  <segs_objs: Segs_Objects> "," <segs_obj: Segs_Obj> => {
    let mut list = segs_objs;
    list.push(segs_obj);
    list
  },
}

Segs_Obj: AstSegsObj = {
  <seg: Seg> => {
    AstSegsObj::new(seg)
  },
  <segs: Segs_Obj> "." <seg: Seg> => {
    let mut segs = segs;
    segs.append(seg);
    segs
  },
}

Seg: AstSeg = {
  "&" <int: "unsigned_int"> => {
    AstSeg::Gid(int)
  },
  "&" <int: "unsigned_int"> <bra_str: "BracketedString"> => {
    AstSeg::GidStr(int, bra_str)
  },
  <bra_str: "BracketedString"> => {
    AstSeg::Str(bra_str)
  },
  <func: Member_Func> => {
    AstSeg::MemberFunc(func)
  },
  <func: Set_Func> => {
    AstSeg::SetFunc(func)
  },
  <func: Exp_Func> => {
    AstSeg::ExpFunc(func)
  },
  <func: Level_Func> => {
    AstSeg::LevelFunc(func)
  },
}

AxisPos: u64 = {
  <axpos: "unsigned_int"> => axpos,
  "Columns"     => 0,
  "Rows"        => 1,
  "Pages"       => 2,
  "Chapters"    => 3,
  "Sections"    => 4,
}

// code review mark >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>>>>>>>>>>>
// code review mark >>>>>>>>>>

Member_Func: AstMemberFunction = {
  <parent: MemberFnParent> => {
    AstMemberFunction::Parent(parent)
  },
  <cp: MemberFnClosingPeriod> => {
    AstMemberFunction::ClosingPeriod(cp)
  },
  <op: MemberFnOpeningPeriod> => {
    AstMemberFunction::OpeningPeriod(op)
  },
  <cur_mbr: MemberFnCurrentMember> => {
    AstMemberFunction::CurrentMember(cur_mbr)
  },

  // << Member Functions >>
}

MemberFnParent: AstMemberFnParent = {
  "Parent" => {
    AstMemberFnParent::NoParam
  },
  "Parent" "(" ")" => {
    AstMemberFnParent::NoParam
  },
  "Parent" "(" <segments: Segs_Obj> ")" => {
    AstMemberFnParent::HasParam(segments)
  },
}

MemberFnClosingPeriod: AstMemberFnClosingPeriod = {
  "ClosingPeriod" => {
    AstMemberFnClosingPeriod::NoParam
  },
  "ClosingPeriod" "(" ")" => {
    AstMemberFnClosingPeriod::NoParam
  },
  "ClosingPeriod" "(" <level_segs: Segs_Obj> ")" => {
    AstMemberFnClosingPeriod::OneParam(level_segs)
  },
  "ClosingPeriod" "(" <level_segs: Segs_Obj> "," <member_segs: Segs_Obj> ")" => {
    AstMemberFnClosingPeriod::TwoParams(level_segs, member_segs)
  },
}

MemberFnOpeningPeriod: AstMemberFnOpeningPeriod = {
  "OpeningPeriod" => {
    AstMemberFnOpeningPeriod::NoParam
  },
  "OpeningPeriod" "(" ")" => {
    AstMemberFnOpeningPeriod::NoParam
  },
  "OpeningPeriod" "(" <level_segs: Segs_Obj> ")" => {
    AstMemberFnOpeningPeriod::OneParam(level_segs)
  },
  "OpeningPeriod" "(" <level_segs: Segs_Obj> "," <member_segs: Segs_Obj> ")" => {
    AstMemberFnOpeningPeriod::TwoParams(level_segs, member_segs)
  },
}

MemberFnCurrentMember: AstMemberFnCurrentMember = {
  "CurrentMember" => {
    AstMemberFnCurrentMember::NoParam
  },
  "CurrentMember" "(" ")" => {
    AstMemberFnCurrentMember::NoParam
  },
  "CurrentMember" "(" <segments: Segs_Obj> ")" => {
    AstMemberFnCurrentMember::InnerParam(segments)
  },
}

Level_Func: AstLevelFunction = {
  <lv: LvFnLevel> => {
    AstLevelFunction::Level(lv)
  },
  <lvs: LvFnLevels> => {
    AstLevelFunction::Levels(lvs)
  },
}

LvFnLevel: AstLevelFnLevel = {
  "Level" => {
    AstLevelFnLevel::NoParam
  },
  "Level" "(" ")" => {
    AstLevelFnLevel::NoParam
  },
  "Level" "(" <segments: Segs_Obj> ")" => {
    AstLevelFnLevel::OneParam(segments)
  },
}

LvFnLevels: AstLevelFnLevels = {
  "Levels" "(" <idx_exp: Expression> ")" => {
    AstLevelFnLevels::new(None, idx_exp)
  },
  "Levels" "(" <dim_segs: Segs_Obj> "," <idx_exp: Expression> ")" => {
    AstLevelFnLevels::new(Some(dim_segs), idx_exp)
  },
}

Expression: AstExpression = {
  <term:Term> => {
    AstExpression {
      terms: vec![(' ', term)],
    }
  },
  <exp:Expression> "+" <term:Term> => {
    let mut e = exp;
    e.terms.push(('+', term));
    e
  },
  <exp:Expression> "-" <term:Term> => {
    let mut e = exp;
    e.terms.push(('-', term));
    e
  }
}

Term: AstTerm = {
  <factory:Factory> => {
    AstTerm {
      factories: vec![(' ', factory)],
    }
  },
  <term:Term> "*" <factory:Factory> => {
    let mut t = term;
    t.factories.push(('*', factory));
    t
  },
  <term:Term> "/" <factory:Factory> => {
    let mut t = term;
    t.factories.push(('/', factory));
    t
  }
}

Factory: AstFactory = {
  <value:"double"> => {
    FactoryNum(value)
  },
  <int_val: "unsigned_int"> => {
    let double_val: f64 = int_val as f64;
    FactoryNum(double_val)
  },
  <str:"QuotedString"> => {
    FactoryStr(str)
  },
  <segs_wrap:Segs_Obj> => {
    FactorySegs(segs_wrap)
  },

  // <tuple_wrap:TupleWrap_2> => {
  //   FactoryTuple(tuple_wrap)
  // },
  "(" <seg_objs: Segs_Objects> "," <seg_obj: Segs_Obj> ")" => {
    let mut seg_objs = seg_objs;
    seg_objs.push(seg_obj);
    FactoryTuple(AstTuple::SegsObjects(seg_objs))
  },

  "(" <exp:Expression> ")" => {
    FactoryExp(exp)
  },
}

Set_Func: AstSetFunction = {
  <chir: SetFnChildrenSpec> => {
    AstSetFunction::Children(chir)
  },
}

SetFnChildrenSpec: AstSetFnChildren = {
  "Children" => {
    AstSetFnChildren::NoParam
  },
  "Children" "(" ")" => {
    AstSetFnChildren::NoParam
  },
  "Children" "(" <segments: Segs_Obj> ")" => {
    AstSetFnChildren::InnerParam(segments)
  },
}

Exp_Func: AstExpFunction = {
  <avg: ExpFnAvgSpec> => {
    AstExpFunction::Avg(avg)
  },
  <count: ExpFnCountSpec> => {
    AstExpFunction::Count(count)
  },
  <iif: ExpFnIIfSpec> => {
    AstExpFunction::IIf(iif)
  },
  <lookup_cube: ExpFnLookupCubeSpec> => {
    AstExpFunction::LookupCube(lookup_cube)
  },
  <name: ExpFnNameSpec> => {
    AstExpFunction::Name(name)
  },
  <exp_fn: Exp_Func_Sum> => {
    AstExpFunction::Sum(exp_fn)
  },
  <exp_fn: Exp_Func_Max> => {
    AstExpFunction::Max(exp_fn)
  },
  <exp_fn: Exp_Func_Min> => {
    AstExpFunction::Min(exp_fn)
  },

  // << Numeric Functions >>
}

ExpFnNameSpec: AstExpFnName = {
  "Name" => {
    AstExpFnName::NoParam
  },
  "Name" "(" ")" => {
    AstExpFnName::NoParam
  },
  "Name" "(" <olap_obj_segs: Segs_Obj> ")" => {
    AstExpFnName::InnerParam(olap_obj_segs)
  },
}

ExpFnCountSpec: AstExpFnCount = {
  "Count" => {
    AstExpFnCount::NoParam
  },
  "Count" "(" ")" => {
    AstExpFnCount::NoParam
  },
  "Count" "(" <set: Brace_Set> ")" => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstExpFnCount::InnerParam(set)
  },
}

ExpFnAvgSpec: AstExpFnAvg = {
  "Avg" => {
    AstExpFnAvg::NoParam
  },
  "Avg" "(" ")" => {
    AstExpFnAvg::NoParam
  },
  "Avg" "(" <set: Brace_Set> ")" => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstExpFnAvg::InnerParam(set)
  },
}

Exp_Func_Sum: AstExpFuncSum = {
  "Sum" ("(" ")")? => {
    AstExpFuncSum::Simple
  },
  // "Sum" "(" <exp: Expression> ")" => {},
  "Sum" "(" <segs_set: Segs_Obj> ")" => {
    AstExpFuncSum::SegsSet(segs_set)
  },
  "Sum" "(" <segs_set: Segs_Obj> "," <exp: Expression> ")" => {
    AstExpFuncSum::SegsSetExp(segs_set, exp)
  },
  "Sum" "(" <cb_set: Brace_Set> ")" => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstExpFuncSum::BraceSet(cb_set)
  },
  "Sum" "(" <cb_set: Brace_Set> "," <exp: Expression> ")" => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstExpFuncSum::BraceSetExp(cb_set, exp)
  },
}

Exp_Func_Max: AstExpFuncMax = {
  "Max" ("(" ")")? => {
    AstExpFuncMax::Simple
  },
  // "Max" "(" <exp: Expression> ")" => {},
  "Max" "(" <segs_set: Segs_Obj> ")" => {
    AstExpFuncMax::SegsSet(segs_set)
  },
  "Max" "(" <segs_set: Segs_Obj> "," <exp: Expression> ")" => {
    AstExpFuncMax::SegsSetExp(segs_set, exp)
  },
  "Max" "(" <cb_set: Brace_Set> ")" => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstExpFuncMax::BraceSet(cb_set)
  },
  "Max" "(" <cb_set: Brace_Set> "," <exp: Expression> ")" => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstExpFuncMax::BraceSetExp(cb_set, exp)
  },
}

Exp_Func_Min: AstExpFuncMin = {
  "Min" ("(" ")")? => {
    AstExpFuncMin::Simple
  },
  // "Min" "(" <exp: Expression> ")" => {},
  "Min" "(" <segs_set: Segs_Obj> ")" => {
    AstExpFuncMin::SegsSet(segs_set)
  },
  "Min" "(" <segs_set: Segs_Obj> "," <exp: Expression> ")" => {
    AstExpFuncMin::SegsSetExp(segs_set, exp)
  },
  "Min" "(" <cb_set: Brace_Set> ")" => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstExpFuncMin::BraceSet(cb_set)
  },
  "Min" "(" <cb_set: Brace_Set> "," <exp: Expression> ")" => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstExpFuncMin::BraceSetExp(cb_set, exp)
  },
}

ExpFnIIfSpec: AstExpFnIIf = {
  "IIf" "(" <bool_exp: BoolExpression> "," <exp_t: Expression> "," <exp_f: Expression> ")" => {
    AstExpFnIIf {
      bool_exp,
      exp_t,
      exp_f,
    }
  }
}

ExpFnLookupCubeSpec: AstExpFnLookupCube = {
    "Tunnel" "(" <cube_segs: Segs_Obj> "," <exp_on_another_cube: Expression> ")" => {
      AstExpFnLookupCube::new(Some(cube_segs), exp_on_another_cube)
    },
    "Tunnel" "(" <exp_on_another_cube: Expression> ")" => {
      AstExpFnLookupCube::new(None, exp_on_another_cube)
    },
}

BoolExpression: AstBoolExp = {
  <bt: BoolTerm> => {
    AstBoolExp::BoolTerm(bt)
  },
  "Not" <bt: BoolTerm> => {
    AstBoolExp::NotBoolTerm(bt)
  },
  <bool_exp: BoolExpression> "Or" <bt: BoolTerm> => {
    AstBoolExp::BoolExpOrBoolTerm(Box::new(bool_exp), bt)
  }
}

BoolTerm: AstBoolTerm = {
  <bf: BoolFactory> => {
    AstBoolTerm::BoolFactory(bf)
  },
  <bt: BoolTerm> "And" <bf: BoolFactory> => {
    AstBoolTerm::BoolTermAndBoolFactory(Box::new(bt), bf)
  }
}

BoolFactory: AstBoolFactory = {
  <exp_left: Expression> "<" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from("<"), exp_right)
  },
  <exp_left: Expression> "<=" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from("<="), exp_right)
  },
  <exp_left: Expression> "=" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from("="), exp_right)
  },
  <exp_left: Expression> "<>" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from("<>"), exp_right)
  },
  <exp_left: Expression> ">" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from(">"), exp_right)
  },
  <exp_left: Expression> ">=" <exp_right: Expression> => {
    AstBoolFactory::ExpressionComparesAnother(exp_left, String::from(">="), exp_right)
  },
  "(" <bool_exp: BoolExpression> ")" => {
    AstBoolFactory::BoolExp(Box::new(bool_exp))
  },
  <bool_fn: BoolFunction> => {
    AstBoolFactory::BoolFn(bool_fn)
  }
}

BoolFunction: AstBoolFunction = {
  <is_leaf: BoolFnIsLeaf> => {
    AstBoolFunction::IsLeaf(is_leaf)
  }
}

BoolFnIsLeaf: AstBoolFnIsLeaf = {
  // "IsLeaf" => {
  //   AstBoolFnIsLeaf::new(None)
  // },
  // "IsLeaf" "(" ")" => {
  //   AstBoolFnIsLeaf::new(None)
  // },
  "IsLeaf" "(" <member_segs: Segs_Obj> ")" => {
    AstBoolFnIsLeaf::new(member_segs)
  },
}

// COLUMNS | ROWS | PAGES | CHAPTERS | SECTIONS | AXIS (<unsigned_integer>)
Axis: AstAxis = {
  <ast_set:Brace_Set> "on" <axpos:AxisPos> => { // <crace_set: Brace_Set> <set_segs: Segs_Obj>
    AstAxis::SetDefinition {
      ast_set,
      pos: axpos,
    }
  }
}

Axes: Vec<AstAxis> = {
  <axis:Axis> => {
    vec![axis]
  },
  <axes:Axes> "," <axis:Axis> => {
    let mut list = axes;
    list.push(axis);
    list
  }
}
