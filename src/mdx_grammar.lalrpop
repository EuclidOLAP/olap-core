use crate::mdx_tokens::{Token, LexicalError};
use crate::mdx_ast;

grammar;

// ...

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "select" => Token::Select,
    "on" => Token::On,
    "from" => Token::From,
    "where" => Token::Where,
    "BracketedString" => Token::BracketedString(<String>),

    "&" => Token::Ampersand,
    "." => Token::Dot,
    "int" => Token::Integer(<u64>),


    // "var" => Token::KeywordVar,
    // "print" => Token::KeywordPrint,
    // "identifier" => Token::Identifier(<String>),
    // "int" => Token::Integer(<i64>),
    // "(" => Token::LParen,
    // ")" => Token::RParen,
    // "=" => Token::Assign,
    // ";" => Token::Semicolon,
    // "+" => Token::OperatorAdd,
    // "-" => Token::OperatorSub,
    // "*" => Token::OperatorMul,
    // "/" => Token::OperatorDiv,
    // // The following is testing feature flags for lexing
    // #[cfg(feature = "bit")]
    // "<<" => Token::OperatorShl,
  }
}


// multi-dimensional object segment
pub Seg: mdx_ast::AstSeg = {
  "&" <int:"int"> => {
    mdx_ast::AstSeg {
      gid: Some(int),
      seg_str: None,
    }
  },
  "&" <int:"int"> <bra_str:"BracketedString"> => {
    mdx_ast::AstSeg {
      gid: Some(int),
      seg_str: Some(bra_str),
    }
  },
  <bra_str:"BracketedString"> => {
    mdx_ast::AstSeg {
      gid: None,
      seg_str: Some(bra_str),
    }
  },
}

pub Segments: Vec<mdx_ast::AstSeg> = {
  <seg:Seg> => {
    let mut list = Vec::with_capacity(6);
    list.push(seg);
    list
  },
  <segs:Segments> "." <seg:Seg> => {
    let mut list = segs;
    list.push(seg);
    list
  }
}


// pub BlocksChain: Vec<String> = {
//   <bra_str:"BracketedString"> => {
//     vec![bra_str.to_string()]
//   },
//   <chain:BlocksChain> "." <bra_str:"BracketedString"> => {
//     // format!("{}.{}", chain, bra_str)
//     let mut list = chain;
//     list.push(bra_str.to_string());
//     list
//   }
// }

pub MdxStatement: mdx_ast::ExtMDXStatement = {
  "select" "on" "from" "where" => {
    mdx_ast::ExtMDXStatement::Querying { basic_cube: mdx_ast::AstCube{} }
  }
}










// pub Script: Vec<ast::Statement> = {
//   <stmts:Statement*> => stmts
// }

// pub Statement: ast::Statement = {
//   "var" <name:"identifier"> "=" <value:Expression> ";" => {
//     ast::Statement::Variable { name, value }
//   },
//   "print" <value:Expression> ";" => {
//     ast::Statement::Print { value }
//   },
// }

// pub Expression: Box<ast::Expression> = {
//   #[precedence(level="1")]
//   Term,

//   #[precedence(level="2")] #[assoc(side="left")]
//   <lhs:Expression> "*" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Mul,
//       rhs
//     })
//   },
//   <lhs:Expression> "/" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Div,
//       rhs
//     })
//   },

//   #[precedence(level="3")] #[assoc(side="left")]
//   <lhs:Expression> "+" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Add,
//       rhs
//     })
//   },
//   <lhs:Expression> "-" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Sub,
//       rhs
//     })
//   },

//   #[cfg(feature = "bit")]
//   #[precedence(level="4")] #[assoc(side="right")]
//   <lhs:Expression> "<<" <rhs:Expression> => {
//     Box::new(ast::Expression::BinaryOperation {
//       lhs,
//       operator: ast::Operator::Shl,
//       rhs
//     })
//   },
// }

// pub Term: Box<ast::Expression> = {
//   <val:"int"> => {
//     Box::new(ast::Expression::Integer(val))
//   },
//   <name:"identifier"> => {
//     Box::new(ast::Expression::Variable(name))
//   },
//   "(" <e:Expression> ")" => e
// }